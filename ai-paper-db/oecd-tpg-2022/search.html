<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>OECD TPG 2022（参考仮訳） - 全文検索（人間向け）</title>
  <meta name="description" content="OECD移転価格ガイドライン2022（参考仮訳）をブラウザで全文検索し、該当パラグラフのcoreテキストへジャンプします。" />
  <style>
    :root { --bg: #0f172a; --panel: #0b1220; --text: #e2e8f0; --muted: #94a3b8; --accent: #38bdf8; --danger: #fb7185; }
    body { margin: 0; background: radial-gradient(1200px 600px at 10% 0%, #1e293b, var(--bg)); color: var(--text); font: 15px/1.6 ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, 'Noto Sans JP', sans-serif; }
    header { padding: 18px 18px 8px; border-bottom: 1px solid rgba(148,163,184,.18); background: rgba(2,6,23,.55); backdrop-filter: blur(10px); position: sticky; top: 0; }
    h1 { margin: 0 0 6px; font-size: 18px; letter-spacing: .01em; }
    .sub { margin: 0; color: var(--muted); font-size: 13px; }
    main { max-width: 980px; margin: 0 auto; padding: 18px; }
    .row { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    input[type="text"] { flex: 1 1 360px; min-width: 240px; padding: 10px 12px; border-radius: 10px; border: 1px solid rgba(148,163,184,.25); background: rgba(2,6,23,.35); color: var(--text); outline: none; }
    input[type="text"]:focus { border-color: rgba(56,189,248,.7); box-shadow: 0 0 0 3px rgba(56,189,248,.15); }
    button { padding: 10px 12px; border-radius: 10px; border: 1px solid rgba(148,163,184,.25); background: rgba(2,6,23,.35); color: var(--text); cursor: pointer; }
    button:hover { border-color: rgba(56,189,248,.7); }
    .pill { display: inline-block; padding: 2px 8px; border-radius: 999px; border: 1px solid rgba(148,163,184,.25); color: var(--muted); font-size: 12px; }
    .note { margin: 10px 0 0; color: var(--muted); font-size: 13px; }
    .warn { color: #fecaca; }
    .stats { margin: 14px 0 10px; color: var(--muted); font-size: 13px; }
    .results { display: grid; gap: 10px; }
    .card { border: 1px solid rgba(148,163,184,.18); border-radius: 12px; background: rgba(2,6,23,.28); padding: 12px; }
    .card a { color: var(--accent); text-decoration: none; }
    .card a:hover { text-decoration: underline; }
    .meta { display: flex; gap: 10px; flex-wrap: wrap; align-items: baseline; margin-bottom: 8px; }
    .snippet { white-space: pre-wrap; word-break: break-word; }
    footer { margin-top: 18px; color: var(--muted); font-size: 12px; }
    code { background: rgba(148,163,184,.12); padding: 1px 6px; border-radius: 6px; }
  </style>
</head>
<body>
  <header>
    <h1>OECD TPG 2022（参考仮訳） 全文検索（人間向け）</h1>
    <p class="sub">ブラウザ上で <span class="pill">source/2022translated.txt</span> を読み込み、検索結果から <code>core/...</code> にジャンプします。</p>
  </header>

  <main>
    <div class="row">
      <input id="q" type="text" placeholder="例: 無形資産 / 便益テスト / HTVI / CCA / リスク" />
      <button id="btnLoad">Load</button>
      <button id="btnSearch">Search</button>
      <span id="status" class="pill">idle</span>
    </div>
    <p class="note">
      重要: これは人間向け（ブラウザ全文検索）。モバイルAIの「先頭1万トークンのみ」制約の最適解は <a href="quickstart.txt">quickstart.txt</a> を参照。
      <span class="warn">本ページは約1.7MBのテキストを読むため、低速回線では読み込みに時間がかかります。</span>
    </p>

    <div class="stats" id="stats"></div>
    <div class="results" id="results"></div>

    <footer>
      Source: <a href="source/2022translated.txt">source/2022translated.txt</a> /
      Dataset: <a href="./">index</a> /
      AI: <a href="quickstart.txt">quickstart</a>
    </footer>
  </main>

  <script>
    const SOURCE_URL = "source/2022translated.txt";
    const PAGE_RE = /^===== Page (\\d+) =====$/gm;
    const PARA_RE = /^(\\d+(?:[\\.．]\\d+)+)[\\.．]?\\s+/gm;
    const MAX_RESULTS = 200;

    const qEl = document.getElementById("q");
    const btnLoad = document.getElementById("btnLoad");
    const btnSearch = document.getElementById("btnSearch");
    const statusEl = document.getElementById("status");
    const statsEl = document.getElementById("stats");
    const resultsEl = document.getElementById("results");

    let text = null;
    let pageMarks = []; // [{page, index}]
    let paraMarks = []; // [{pid, index}]

    function setStatus(s) { statusEl.textContent = s; }

    function normalizePid(pid) {
      return (pid || "")
        .replace(/[０-９]/g, (d) => String.fromCharCode(d.charCodeAt(0) - 0xFEE0))
        .replace(/．/g, ".");
    }

    function buildMarks() {
      pageMarks = [];
      paraMarks = [];

      PAGE_RE.lastIndex = 0;
      let m;
      while ((m = PAGE_RE.exec(text)) !== null) {
        pageMarks.push({ page: Number(m[1]), index: m.index });
      }

      PARA_RE.lastIndex = 0;
      while ((m = PARA_RE.exec(text)) !== null) {
        paraMarks.push({ pid: normalizePid(m[1]), index: m.index });
      }
    }

    function findLastMark(arr, pos) {
      // Binary search: last mark with index <= pos.
      let lo = 0, hi = arr.length - 1, ans = null;
      while (lo <= hi) {
        const mid = (lo + hi) >> 1;
        if (arr[mid].index <= pos) {
          ans = arr[mid];
          lo = mid + 1;
        } else {
          hi = mid - 1;
        }
      }
      return ans;
    }

    function coreLinkFor(pos) {
      const page = findLastMark(pageMarks, pos)?.page ?? null;
      const pid = findLastMark(paraMarks, pos)?.pid ?? null;
      if (page == null || !pid) return null;
      const pageStr = String(page).padStart(3, "0");
      return `core/p${pageStr}-${pid}.txt`;
    }

    function escapeHtml(s) {
      return (s || "").replace(/[&<>"]/g, (c) => ({ "&": "&amp;", "<": "&lt;", ">": "&gt;", "\"": "&quot;" }[c]));
    }

    async function loadText() {
      setStatus("loading...");
      statsEl.textContent = "";
      resultsEl.textContent = "";

      const res = await fetch(SOURCE_URL, { cache: "force-cache" });
      if (!res.ok) throw new Error(`failed to fetch: ${res.status}`);
      text = await res.text();
      buildMarks();
      setStatus("ready");
      statsEl.textContent = `Loaded ${text.length.toLocaleString()} chars / pages: ${pageMarks.length.toLocaleString()} / paragraph markers: ${paraMarks.length.toLocaleString()}`;
    }

    function doSearch() {
      const q = (qEl.value || "").trim();
      resultsEl.textContent = "";
      if (!q) {
        statsEl.textContent = "Query is empty.";
        return;
      }
      if (!text) {
        statsEl.textContent = "Not loaded yet. Click Load first.";
        return;
      }

      const t0 = performance.now();
      let pos = 0;
      let n = 0;
      let shown = 0;
      const cards = [];

      while (true) {
        const hit = text.indexOf(q, pos);
        if (hit === -1) break;
        n += 1;

        if (shown < MAX_RESULTS) {
          const page = findLastMark(pageMarks, hit)?.page ?? "?";
          const core = coreLinkFor(hit);
          const start = Math.max(0, hit - 80);
          const end = Math.min(text.length, hit + q.length + 160);
          const raw = text.slice(start, end).replace(/\\s+/g, " ").trim();
          const snippet = escapeHtml(raw).replaceAll(escapeHtml(q), `<mark>${escapeHtml(q)}</mark>`);

          const meta = [];
          meta.push(`<span class="pill">page ${page}</span>`);
          if (core) meta.push(`<a class="pill" href="${core}">${core}</a>`);

          cards.push(
            `<div class="card">` +
              `<div class="meta">${meta.join(" ")}</div>` +
              `<div class="snippet">${snippet}</div>` +
            `</div>`
          );
          shown += 1;
        }

        pos = hit + q.length;
        if (pos >= text.length) break;
      }

      const t1 = performance.now();
      statsEl.textContent =
        `Hits: ${n.toLocaleString()} (showing ${Math.min(n, MAX_RESULTS).toLocaleString()}) / ${Math.round(t1 - t0)}ms`;
      resultsEl.innerHTML = cards.join("");
    }

    btnLoad.addEventListener("click", async () => {
      try { await loadText(); }
      catch (e) { setStatus("error"); statsEl.textContent = String(e); }
    });
    btnSearch.addEventListener("click", doSearch);
    qEl.addEventListener("keydown", (e) => {
      if (e.key === "Enter") doSearch();
    });

    // Convenience: auto-load if query is provided via URL (?q=...)
    try {
      const url = new URL(location.href);
      const q0 = url.searchParams.get("q");
      if (q0) qEl.value = q0;
    } catch {}
  </script>
</body>
</html>

